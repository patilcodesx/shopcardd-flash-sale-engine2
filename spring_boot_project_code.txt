========== ./ARCHITECTURE.md ==========
# Flash Sale System Design Documentation

---

# Scenario 1: Offline Voucher Verification (‚ÄúOffline JuGaad‚Äù)

---

## Situation

A customer arrives at a merchant store with a successfully claimed voucher.

However, the merchant‚Äôs device temporarily has **no internet connectivity**, making it impossible to call backend APIs for voucher verification.

---

## Challenge

The merchant must still be able to verify:

- The voucher is genuine  
- The voucher has not been modified  
- The voucher has not expired  

All **without contacting the backend server**.

---

## Design Goal

Enable **secure offline voucher validation** without backend dependency while maintaining strong protection against fraud, replay attacks, and data tampering.

---

## Design Approach

Instead of attempting to replicate backend validation logic offline, the **voucher itself is designed to be self-verifiable**.

The backend becomes the **issuer of trust**, while the merchant application performs **local cryptographic verification**.

 

---

## Solution: Signed Offline Voucher Tokens

When a deal is successfully claimed:

1. Backend creates a voucher payload  
2. Payload is cryptographically signed  
3. Signed token is returned to the client  
4. Token is embedded inside a **QR code**

---

## Voucher Payload Fields

The backend generates a payload containing:

- `voucherId` ‚Äì unique identifier  
- `dealId` ‚Äì associated deal  
- `userId` ‚Äì claiming user  
- `expiry` ‚Äì expiration timestamp  

---

## Cryptographic Signing Methods

The payload is signed using one of the following:

### Option 1: JWT with RSA (RS256)

- Backend signs using **private key**
- Merchant verifies using **public key**
- Public key can be distributed safely

### Option 2: HMAC SHA-256

- Backend and merchant share a secret key
- Faster but less flexible for public distribution

---

## Voucher Token Structure

```json
{
  "voucherId": "VCH_8937423",
  "dealId": "DEAL_1029",
  "userId": "USR_55221",
  "expiry": "2026-01-20T23:59:59Z",
  "signature": "BASE64_ENCODED_SIGNATURE"
}
```
## Digital Signature Guarantees

The digital signature guarantees:

- **Payload authenticity**
- **Tamper detection**
- **Data integrity**

Any modification invalidates the signature.

---

## QR Code Contents

The QR code stores:

- Complete signed voucher token (JWT or custom format)
- No backend call required during scan

---

## Offline Verification Flow

Before going offline, the merchant application stores:

- **Public key** (JWT / RSA)
- **Shared secret** (HMAC)

---

### Step-by-Step Verification

1. Merchant scans QR code  
2. Voucher token is extracted  
3. Signature is verified locally  
4. Voucher payload is decoded  
5. Expiry timestamp is checked  
6. Voucher schema is validated  

If all checks pass ‚Üí **Voucher Accepted**

---

## Offline Validation Logic

```bash
if signature_valid \
   and current_time < expiry \
   and voucher_format_valid
then
   accept_voucher
else
   reject_voucher
fi
```
## Preventing Abuse in Offline Mode

Offline systems are vulnerable to repeated usage.

To mitigate this:

---

### Local Redemption Tracking

- Merchant device stores a local list:
  - `redeemed_voucher_ids`

- If the same voucher is scanned again:
  - **Rejected immediately**

---

### Sync After Connectivity Returns

Once internet connectivity is restored:

- All offline redemptions are synced
- Backend permanently marks vouchers as redeemed
- Conflicts are resolved server-side

---

## Security Guarantees

| Threat | Mitigation |
|------|-----------|
| QR tampering | Cryptographic signature |
| Fake vouchers | Private-key signing |
| Expired vouchers | Timestamp validation |
| Duplicate scans | Local redemption cache |
| Replay attack | Server sync validation |

---







---

# Scenario 2: Handling Massive Scale  
## 1 Million Requests per Minute

---

## Situation

During a flash sale or limited-offer event:

- Up to **1,000,000 requests per minute**
- ~**16,000‚Äì20,000 requests per second**
- Majority of traffic targets only **few popular deals**

---

## Core Challenges

- Prevent overselling inventory  
- Prevent duplicate claims  
- Maintain sub-100ms latency  
- Avoid database meltdown  
- Handle burst traffic safely  

---

## High-Level Scaling Philosophy

The system scales by:

- Isolating contention  
- Centralizing concurrency control  
- Keeping application layer stateless  
- Using Redis as a traffic gate  
- Using database as final authority  

---

## 1Ô∏è‚É£ Stateless Application Layer

Spring Boot services are completely stateless:

- No HTTP sessions  
- No in-memory locks  
- No local caches for correctness  

All state is stored in:

- Redis  
- PostgreSQL  

---

### Advantages

- Horizontal scaling  
- Container-friendly  
- No inter-service coordination  
- Auto-scaling ready  

---

## 2Ô∏è‚É£ Load Balancing Architecture

```bash
Client Requests
      ‚Üì
Cloud Load Balancer
      ‚Üì
Spring Boot App Instances
(App-1 | App-2 | App-3 | App-N)
```
Requests are evenly distributed across all instances.

---

## 3Ô∏è‚É£ Redis-First Concurrency Control

Redis acts as the **first line of defense**.

---

### Deal-Based Distributed Lock

```bash
lock:deal:{dealId}
```
- Requests for the **same deal** compete  
- Requests for **different deals** proceed in parallel  

---

## Redis Lock Behavior

- TTL-based locks prevent deadlocks  
- Atomic operations (`SETNX` / Lua scripts)  
- Extremely low latency (~1 ms)  

---

## Redis Cluster Mode

At scale:

- Redis runs in **cluster mode**  
- Locks distributed across shards  
- Horizontal throughput scaling  

---

# 4Ô∏è‚É£ Database as Source of Truth

PostgreSQL remains the **final authority**.

---

## Responsibilities

### Primary DB

- Inventory decrement  
- Voucher claim insert  
- Transaction handling  

### Read Replicas

- Deal listing  
- Deal metadata  
- User history queries  

---

## Database Safety Mechanisms

- ACID transactions  
- Row-level locking  

Unique constraint:

```sql
UNIQUE (deal_id, user_id)
```
### Indexed Fields

- `deal_id`  
- `valid_until`  

Even if Redis fails, the database guarantees correctness.

---

# 5Ô∏è‚É£ Asynchronous Processing (Optional)

To reduce latency under extreme load:

Move non-critical work out of the request path.

---

## Offloaded Operations

- Notifications  
- Email / SMS  
- Analytics  
- Audit logging  

---

## Messaging Tools

- Apache Kafka  
- RabbitMQ  
- AWS SQS  

---

## Claim Request Execution Flow

```bash
Client Request
   ‚Üì
Load Balancer
   ‚Üì
Spring Boot App
   ‚Üì
Redis Lock Check
   ‚Üì
PostgreSQL Transaction
   ‚Üì
Commit / Rollback
   ‚Üì
Async Events Published
```
## Final Scaled Architecture

```bash
Clients
   ‚Üì
Load Balancer
   ‚Üì
Spring Boot Containers (Auto-Scaled)
   ‚Üì
Redis Cluster (Locks + Cache)
   ‚Üì
PostgreSQL Primary
   ‚Üì
PostgreSQL Read Replicas
```
## Key Design Outcomes

- No overselling  
- No duplicate claims  
- Linear horizontal scalability  
- Predictable latency  
- Strong consistency  
- Fault tolerance  

---

## Technologies Used

- **Backend:** Java Spring Boot  
- **Cache / Locks:** Redis Cluster  
- **Database:** PostgreSQL  
- **Messaging:** Kafka / RabbitMQ  
- **Deployment:** Docker + Kubernetes  
- **Security:** JWT, RSA, HMAC  

---
========== ./.mvn/wrapper/maven-wrapper.properties ==========
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.12/apache-maven-3.9.12-bin.zip
========== ./docker-compose.yml ==========
services:
  postgres:
    image: postgres:15-alpine
    container_name: flashsale-postgres
    environment:
      POSTGRES_DB: flashsale
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    container_name: flashsale-redis
    ports:
      - "6379:6379"

  app:
    build: .
    container_name: flashsale-app
    ports:
      - "8080:8080"
    depends_on:
      - postgres
      - redis

volumes:
  pgdata:
========== ./pom.xml ==========
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.9</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.shopcardd</groupId>
	<artifactId>flashsale</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>flashsale</name>
	<description>Hyperlocal Flash Sale Backend Service</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- PostgreSQL ONLY -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

</dependencies>



	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
========== ./target/classes/application.properties ==========
spring.application.name=flashsale
server.port=8080

# PostgreSQL
spring.datasource.url=jdbc:postgresql://postgres:5432/flashsale
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Redis
spring.data.redis.host=redis
spring.data.redis.port=6379
========== ./target/classes/application-docker.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/flashsale
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    show-sql: true

  redis:
    host: redis
    port: 6379

server:
  port: 8080
========== ./src/main/resources/application.properties ==========
spring.application.name=flashsale
server.port=8080

# PostgreSQL
spring.datasource.url=jdbc:postgresql://postgres:5432/flashsale
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Redis
spring.data.redis.host=redis
spring.data.redis.port=6379
========== ./src/main/resources/application-docker.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/flashsale
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    show-sql: true

  redis:
    host: redis
    port: 6379

server:
  port: 8080
========== ./src/main/java/com/shopcardd/flashsale/exception/AlreadyClaimedException.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class AlreadyClaimedException extends RuntimeException {

    public AlreadyClaimedException(String message) {
        super(message);
    }
}
========== ./src/main/java/com/shopcardd/flashsale/exception/GlobalExceptionHandler.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.shopcardd.flashsale.dto.ApiResponse;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<ApiResponse> handle(RuntimeException ex) {

        HttpStatus status =
                ex.getClass().isAnnotationPresent(ResponseStatus.class)
                        ? ex.getClass().getAnnotation(ResponseStatus.class).value()
                        : HttpStatus.BAD_REQUEST;

        return new ResponseEntity<>(
               new ApiResponse("fail",ex.getMessage()),
                status
        );
    }
}
========== ./src/main/java/com/shopcardd/flashsale/exception/DealLockedException.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class DealLockedException extends RuntimeException {

    public DealLockedException(String message) {
        super(message);
    }
}
========== ./src/main/java/com/shopcardd/flashsale/exception/DealNotFoundException.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class DealNotFoundException extends RuntimeException {

    public DealNotFoundException(String message) {
        super(message);
    }
}
========== ./src/main/java/com/shopcardd/flashsale/exception/DealSoldOutException.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.CONFLICT)
public class DealSoldOutException extends RuntimeException {
   public DealSoldOutException(String message){
    super(message);
   }
   
}
========== ./src/main/java/com/shopcardd/flashsale/exception/DealExpiredException.java ==========
package com.shopcardd.flashsale.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class DealExpiredException extends RuntimeException {

    public DealExpiredException(String message) {
        super(message);
    }
}
========== ./src/main/java/com/shopcardd/flashsale/config/JacksonConfig.java ==========
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }
}
========== ./src/main/java/com/shopcardd/flashsale/config/RedisConfig.java ==========
package com.shopcardd.flashsale.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
public class RedisConfig {

    @Bean
    public StringRedisTemplate redisTemplate(
            RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}
========== ./src/main/java/com/shopcardd/flashsale/service/GeoUtils.java ==========
package com.shopcardd.flashsale.service;

public class GeoUtils {

    private static final double EARTH_RADIUS_KM = 6371.0;

    public static double distanceKm(
            double lat1, double lon1,
            double lat2, double lon2
    ) {
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);

        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2)
                + Math.cos(Math.toRadians(lat1))
                * Math.cos(Math.toRadians(lat2))
                * Math.sin(dLon / 2)
                * Math.sin(dLon / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS_KM * c;
    }
}
========== ./src/main/java/com/shopcardd/flashsale/service/DealService.java ==========
package com.shopcardd.flashsale.service;

import com.shopcardd.flashsale.dto.CreateDealRequest;
import com.shopcardd.flashsale.dto.DealResponse;
import com.shopcardd.flashsale.exception.*;
import com.shopcardd.flashsale.model.Claim;
import com.shopcardd.flashsale.model.Deal;
import com.shopcardd.flashsale.repository.ClaimRepository;
import com.shopcardd.flashsale.repository.DealRepository;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.List;

@Service
@RequiredArgsConstructor
public class DealService {

    private final DealRepository dealRepository;
    private final ClaimRepository claimRepository;
    private final StringRedisTemplate redisTemplate;
    private final ObjectMapper objectMapper;

    /* -------------------- CREATE DEAL -------------------- */

    public DealResponse createDeal(CreateDealRequest request) {

    Deal deal = Deal.builder()
            .merchantId(request.getMerchantId())
            .title(request.getTitle())
            .totalInventory(request.getTotalVouchers())
            .inventoryRemaining(request.getTotalVouchers())
            .validUntil(request.getValidUntil())
            .latitude(request.getLocation().getLat())
            .longitude(request.getLocation().getLng())
            .build();

    // 1Ô∏è‚É£ Save first to generate UUID
    Deal savedDeal = dealRepository.save(deal);

    // 2Ô∏è‚É£ Store inventory in Redis
   redisTemplate.opsForValue().set(
    "deal:inventory:" + savedDeal.getDealId(),
    String.valueOf(savedDeal.getTotalInventory()),
    Duration.between(Instant.now(), savedDeal.getValidUntil())
);


    return toResponse(savedDeal);
}


    private DealResponse toResponse(Deal deal) {
        return DealResponse.builder()
                .dealId(deal.getDealId())
                .merchantId(deal.getMerchantId())
                .title(deal.getTitle())
                .totalVouchers(deal.getTotalInventory())
                .inventoryRemaining(deal.getInventoryRemaining())
                .validUntil(deal.getValidUntil())
                .location(
                        DealResponse.Location.builder()
                                .lat(deal.getLatitude())
                                .lng(deal.getLongitude())
                                .build()
                )
                .build();
    }

    /* -------------------- CLAIM DEAL (CORE CHALLENGE) -------------------- */

  @Transactional
public void claimDeal(String dealId, String userId) {

    String lockKey = "lock:deal:" + dealId;

    Boolean lockAcquired = redisTemplate
            .opsForValue()
            .setIfAbsent(lockKey, userId, Duration.ofSeconds(10));

    if (Boolean.FALSE.equals(lockAcquired)) {
        throw new DealLockedException("Deal is currently being claimed. Try again.");
    }

    try {

        String inventoryKey = "deal:inventory:" + dealId;
        String userSetKey = "deal:users:" + dealId;

        // duplicate check
        if (Boolean.TRUE.equals(
                redisTemplate.opsForSet().isMember(userSetKey, userId))) {
            throw new AlreadyClaimedException("User already claimed");
        }

        // atomic inventory
        Long remaining = redisTemplate.opsForValue().decrement(inventoryKey);

        if (remaining == null || remaining < 0) {
            redisTemplate.opsForValue().increment(inventoryKey);
            throw new DealSoldOutException("Deal Sold Out");
        }

        Deal deal = dealRepository.findById(dealId)
                .orElseThrow(() -> new DealNotFoundException("Deal not found"));

        if (deal.getValidUntil().isBefore(Instant.now())) {
            redisTemplate.opsForValue().increment(inventoryKey);
            throw new DealExpiredException("Deal expired");
        }

        redisTemplate.opsForSet().add(userSetKey, userId);

        // expire user set
        redisTemplate.expire(
                userSetKey,
                Duration.between(Instant.now(), deal.getValidUntil())
        );

        claimRepository.save(
                Claim.builder()
                        .dealId(dealId)
                        .userId(userId)
                        .claimedAt(Instant.now())
                        .build()
        );

        deal.setInventoryRemaining(remaining.intValue());
        dealRepository.save(deal);

    } finally {

        redisTemplate.execute(
                new DefaultRedisScript<>(
                        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                        "return redis.call('del', KEYS[1]) else return 0 end",
                        Long.class
                ),
                List.of(lockKey),
                userId
        );
    }
}

    /* -------------------- DISCOVER DEALS (WITH REDIS CACHE) -------------------- */

    public List<DealResponse> discoverDeals(double lat, double lng, double radiusKm) {

        String cacheKey = String.format(
                "cache:deals:%.4f:%.4f:%.1f",
                lat, lng, radiusKm
        );

        // 1Ô∏è‚É£ Try Redis cache
        String cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            try {
                return objectMapper.readValue(
                        cached,
                        new TypeReference<List<DealResponse>>() {}
                );
            } catch (Exception ignored) {
                // fallback to DB
            }
        }

        // 2Ô∏è‚É£ Fetch active deals from DB
        List<Deal> activeDeals =
                dealRepository.findByValidUntilAfterAndInventoryRemainingGreaterThan(
                        Instant.now(), 0
                );

        List<DealResponse> response = activeDeals.stream()
                .filter(deal ->
                        GeoUtils.distanceKm(
                                lat, lng,
                                deal.getLatitude(), deal.getLongitude()
                        ) <= radiusKm
                )
                .map(deal -> {
                    double distance = GeoUtils.distanceKm(
                            lat, lng,
                            deal.getLatitude(), deal.getLongitude()
                    );

                    return DealResponse.builder()
                            .dealId(deal.getDealId())
                            .merchantId(deal.getMerchantId())
                            .title(deal.getTitle())
                            .totalVouchers(deal.getTotalInventory())
                            .inventoryRemaining(deal.getInventoryRemaining())
                            .validUntil(deal.getValidUntil())
                            .distanceKm(distance)
                            .location(
                                    DealResponse.Location.builder()
                                            .lat(deal.getLatitude())
                                            .lng(deal.getLongitude())
                                            .build()
                            )
                            .build();
                })

                .toList();

        // 3Ô∏è‚É£ Store in Redis (TTL = 30s)
        try {
            redisTemplate.opsForValue().set(
                    cacheKey,
                    objectMapper.writeValueAsString(response),
                    Duration.ofSeconds(30)
            );
        } catch (Exception ignored) {}

        return response;
    }
}
========== ./src/main/java/com/shopcardd/flashsale/model/Deal.java ==========
package com.shopcardd.flashsale.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.Instant;

@Entity
@Table(name = "deals")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Deal {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String dealId;

    @Column(nullable = false)
    private String merchantId;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private int totalInventory;

    @Column(nullable = false)
    private int inventoryRemaining;

    @Column(nullable = false)
    private Instant validUntil;

    @Column(nullable = false)
    private double latitude;

    @Column(nullable = false)
    private double longitude;
}
========== ./src/main/java/com/shopcardd/flashsale/model/Claim.java ==========
package com.shopcardd.flashsale.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;

@Entity
@Table(
        name = "claims",
        uniqueConstraints = @UniqueConstraint(columnNames = {"deal_id", "user_id"})
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Claim {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "deal_id", nullable = false)
    private String dealId;

    @Column(name = "user_id", nullable = false)
    private String userId;

    @Column(nullable = false)
    private Instant claimedAt;
}
========== ./src/main/java/com/shopcardd/flashsale/FlashsaleApplication.java ==========
package com.shopcardd.flashsale;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FlashsaleApplication {

	public static void main(String[] args) {
		SpringApplication.run(FlashsaleApplication.class, args);
	}

}
========== ./src/main/java/com/shopcardd/flashsale/controller/DealController.java ==========
package com.shopcardd.flashsale.controller;

import com.shopcardd.flashsale.dto.ClaimRequest;
import com.shopcardd.flashsale.dto.CreateDealRequest;
import com.shopcardd.flashsale.dto.DealResponse;
import com.shopcardd.flashsale.model.Deal;
import com.shopcardd.flashsale.service.DealService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/deals")
@RequiredArgsConstructor
public class DealController {

    private final DealService dealService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public DealResponse createDeal(
            @Valid @RequestBody CreateDealRequest request
    ) {
        return dealService.createDeal(request);
    }


    @GetMapping("/discover")
public Map<String, List<DealResponse>> discoverDeals(
        @RequestParam double lat,
        @RequestParam double lng,
        @RequestParam double radius
) {
    List<DealResponse> deals = dealService.discoverDeals(lat, lng, radius);

    return Map.of("deals", deals);
}


 @PostMapping("/{dealId}/claim")
public Map<String, String> claimDeal(
        @PathVariable String dealId,
        @RequestParam(required = false) String userId,
        @RequestBody(required = false) ClaimRequest request
) {
    String finalUserId;

    if (userId != null && !userId.isBlank()) {
        finalUserId = userId;
    } else if (request != null && request.getUserId() != null) {
        finalUserId = request.getUserId();
    } else {
        throw new IllegalArgumentException("userId is required");
    }

    dealService.claimDeal(dealId, finalUserId);

   return Map.of(
        "status", "success",
        "voucher_code", "SHOP-" + dealId.substring(0, 6)
    );
}




}
========== ./src/main/java/com/shopcardd/flashsale/dto/CreateDealRequest.java ==========
package com.shopcardd.flashsale.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.time.Instant;

import com.fasterxml.jackson.annotation.JsonProperty;

@Data
public class CreateDealRequest {

    @NotBlank
    @JsonProperty("merchant_id")
    private String merchantId;

    @NotBlank
    private String title;

    @Min(1)
    @JsonProperty("total_vouchers")
    private int totalVouchers;

    @NotNull
    @JsonProperty("valid_until")
    private Instant validUntil;

    @NotNull
    private Location location;

    @Data
    public static class Location {

        private double lat;

        @JsonProperty("long")
        private double lng;
    }
}
========== ./src/main/java/com/shopcardd/flashsale/dto/ApiResponse.java ==========
package com.shopcardd.flashsale.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ApiResponse {

    private String status;
    private String reason;
}
========== ./src/main/java/com/shopcardd/flashsale/dto/DealResponse.java ==========
package com.shopcardd.flashsale.dto;

import lombok.Builder;
import lombok.Data;

import java.time.Instant;

import com.fasterxml.jackson.annotation.JsonProperty;

@Data
@Builder
public class DealResponse {

    @JsonProperty("deal_id")
    private String dealId;

    @JsonProperty("merchant_id")
    private String merchantId;

    private String title;

    @JsonProperty("total_vouchers")
    private int totalVouchers;


    @JsonProperty("distance_km")
    private double distanceKm;


    @JsonProperty("inventory_remaining")
    private int inventoryRemaining;

    @JsonProperty("valid_until")
    private Instant validUntil;

    private Location location;

    @Data
    @Builder
    public static class Location {
        private double lat;

        @JsonProperty("long")
        private double lng;
    }
}
========== ./src/main/java/com/shopcardd/flashsale/dto/ClaimRequest.java ==========
package com.shopcardd.flashsale.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class ClaimRequest {

    @NotBlank
    private String userId;
}
========== ./src/main/java/com/shopcardd/flashsale/repository/DealRepository.java ==========
package com.shopcardd.flashsale.repository;

import com.shopcardd.flashsale.model.Deal;
import org.springframework.data.jpa.repository.JpaRepository;
import java.time.Instant;
import java.util.List;

public interface DealRepository extends JpaRepository<Deal, String> {

    List<Deal> findByValidUntilAfterAndInventoryRemainingGreaterThan(
            Instant now,
            int inventory
    );
}
========== ./src/main/java/com/shopcardd/flashsale/repository/ClaimRepository.java ==========
package com.shopcardd.flashsale.repository;

import com.shopcardd.flashsale.model.Claim;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ClaimRepository extends JpaRepository<Claim, Long> {

    Optional<Claim> findByDealIdAndUserId(String dealId, String userId);
}
========== ./README.md ==========
# üõí ShopCardd ‚Äì Hyperlocal Flash Sale Engine

Backend service for managing **high-concurrency flash sales**, enabling merchants to create limited-inventory deals and users to safely discover and claim vouchers **without overselling**.

---

## üöÄ Tech Stack

| Layer | Technology |
|------|-----------|
| Language | Java 17 |
| Framework | Spring Boot |
| Database | PostgreSQL |
| Cache & Locking | Redis |
| Containerization | Docker & Docker Compose |

---

## ‚ú® Features

- Create time-bound flash deals
- Geo-based deal discovery
- Redis-cached discovery results
- Concurrency-safe voucher claiming
- Distributed locking using Redis
- Prevention of overselling and duplicate claims

---

## üß© System Architecture

```
Client
‚Üì
Load Balancer
‚Üì
Spring Boot API
‚Üì
Redis (Distributed Lock + Cache)
‚Üì
PostgreSQL
```

---

## üìÅ Project Folder Structure

```
shopcardd-flash-sale-engine
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ README.md

‚îú‚îÄ‚îÄ src
‚îÇ ‚îî‚îÄ‚îÄ main
‚îÇ ‚îú‚îÄ‚îÄ java
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ com
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ shopcardd
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ flashsale
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ controller
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ service
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ repository
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ entity
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dto
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ config
‚îÇ ‚îî‚îÄ‚îÄ resources
‚îÇ ‚îú‚îÄ‚îÄ application.yml
‚îÇ ‚îî‚îÄ‚îÄ schema.sql
‚îÇ
‚îî‚îÄ‚îÄ pom.xml

```

---

## ‚ñ∂Ô∏è How to Run the Application

### Prerequisites

- Docker
- Docker Compose

---

### Start All Services

```bash
docker compose up --build
```
This will start:

- Spring Boot API
- PostgreSQL
- Redis


## üåê Running Services
| Service | Address |
|--------|---------|
| API | http://localhost:8080 |
| PostgreSQL | localhost:5432 |
| Redis | localhost:6379 |


## üî¥ Redis Setup & Verification


Verify Redis container:

```bash
docker ps
```


Expected output:
```bash
flashsale-redis   redis:7-alpine   Up
```

Connect to Redis CLI:
```bash
docker exec -it flashsale-redis redis-cli
```

Test connection:
```bash
PING
```


Expected:
```bash
PONG
```

Monitor Redis keys:
```bash
MONITOR
```

Common keys:
```bash
lock:deal:{dealId}
cache:deals:{lat}:{lng}:{radius}
```

## üîó API Endpoints
### Create Deal
```bash
POST /deals
```
```json
{
  "merchant_id": "merchant-123",
  "title": "Flat 50% Off",
  "total_vouchers": 100,
  "valid_until": "2026-12-31T23:59:59Z",
  "location": {
    "lat": 19.0760,
    "long": 72.8777
  }
}
```
### Discover Deals
```bash
GET /deals/discover?lat=19.0760&lng=72.8777&radius=5
```

**Behavior**

- Active deals only
- Geo-distance filtering (Haversine formula)
- Redis caching enabled


Cache key:
```bash
cache:deals:{lat}:{lng}:{radius}
```

TTL: 30 seconds

### Claim Deal
```bash
POST /deals/{dealId}/claim?userId=u-1
```

üîê Concurrency Control

Redis distributed locking is used.

Lock key:
```bash
lock:deal:{dealId}
```
### Claim Flow

1. Acquire Redis lock (`SET NX EX`)
2. Validate deal existence
3. Check expiration
4. Check inventory
5. Prevent duplicate claims
6. Decrement inventory
7. Persist claim
8. Release lock safely


### ‚úÖ Guarantees
- Inventory never goes below zero
- One voucher per user
- No overselling
- Safe under heavy concurrency


Safe under heavy concurrency

üìä API Responses
| Scenario | HTTP Status | Sample Response |
|----------|--------------|------------------|
| Successful claim | 200 | `{ "status": "Success", "voucher_code": "SHOP-abc123" }` |
| Already claimed | 400 | `{ "message": "User already claimed this deal" }` |
| Deal sold out | 409 | `{ "message": "Deal sold out" }` |
| Deal expired | 400 | `{ "message": "Deal expired" }` |
| Deal locked | 400 | `{ "message": "Deal is currently being claimed" }` |


## ‚ö†Ô∏è Failure Handling

| Failure | Behavior |
|--------|----------|
| Redis unavailable | Claims rejected (fail-safe) |
| Database error | Transaction rollback |
| Duplicate claim | Gracefully rejected |
| Invalid request | Proper HTTP error |

## üì¶ Deployment Notes

- Stateless Spring Boot services  
- Horizontally scalable  
- Redis handles high-contention operations  
- PostgreSQL remains source of truth  


üë®‚Äçüíª Author

Bhavesh Patil
GitHub: https://github.com/patilcodesx
